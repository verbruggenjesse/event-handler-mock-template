// Code generated by protoc-gen-go. DO NOT EDIT.
// source: event-service.proto

package eventstore

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Event struct {
	Topic                string            `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Action               string            `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
	Metadata             map[string]string `protobuf:"bytes,3,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Payload              string            `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	Id                   string            `protobuf:"bytes,5,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a7d11584ae62cc, []int{0}
}

func (m *Event) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event.Unmarshal(m, b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event.Marshal(b, m, deterministic)
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return xxx_messageInfo_Event.Size(m)
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Event) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *Event) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Event) GetPayload() string {
	if m != nil {
		return m.Payload
	}
	return ""
}

func (m *Event) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Notification struct {
	Topic                string   `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Action               string   `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
	Target               string   `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	Payload              string   `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	Id                   string   `protobuf:"bytes,5,opt,name=id,proto3" json:"id,omitempty"`
	ServiceId            string   `protobuf:"bytes,6,opt,name=serviceId,proto3" json:"serviceId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Notification) Reset()         { *m = Notification{} }
func (m *Notification) String() string { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()    {}
func (*Notification) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a7d11584ae62cc, []int{1}
}

func (m *Notification) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Notification.Unmarshal(m, b)
}
func (m *Notification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Notification.Marshal(b, m, deterministic)
}
func (m *Notification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notification.Merge(m, src)
}
func (m *Notification) XXX_Size() int {
	return xxx_messageInfo_Notification.Size(m)
}
func (m *Notification) XXX_DiscardUnknown() {
	xxx_messageInfo_Notification.DiscardUnknown(m)
}

var xxx_messageInfo_Notification proto.InternalMessageInfo

func (m *Notification) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Notification) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *Notification) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *Notification) GetPayload() string {
	if m != nil {
		return m.Payload
	}
	return ""
}

func (m *Notification) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Notification) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

type DeliveryStatus struct {
	Success              bool     `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Id                   string   `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeliveryStatus) Reset()         { *m = DeliveryStatus{} }
func (m *DeliveryStatus) String() string { return proto.CompactTextString(m) }
func (*DeliveryStatus) ProtoMessage()    {}
func (*DeliveryStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a7d11584ae62cc, []int{2}
}

func (m *DeliveryStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeliveryStatus.Unmarshal(m, b)
}
func (m *DeliveryStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeliveryStatus.Marshal(b, m, deterministic)
}
func (m *DeliveryStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeliveryStatus.Merge(m, src)
}
func (m *DeliveryStatus) XXX_Size() int {
	return xxx_messageInfo_DeliveryStatus.Size(m)
}
func (m *DeliveryStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DeliveryStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DeliveryStatus proto.InternalMessageInfo

func (m *DeliveryStatus) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *DeliveryStatus) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type SubscribeRequest struct {
	Subscriptions        []*Key   `protobuf:"bytes,1,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeRequest) Reset()         { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()    {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a7d11584ae62cc, []int{3}
}

func (m *SubscribeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeRequest.Unmarshal(m, b)
}
func (m *SubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeRequest.Marshal(b, m, deterministic)
}
func (m *SubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeRequest.Merge(m, src)
}
func (m *SubscribeRequest) XXX_Size() int {
	return xxx_messageInfo_SubscribeRequest.Size(m)
}
func (m *SubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeRequest proto.InternalMessageInfo

func (m *SubscribeRequest) GetSubscriptions() []*Key {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

type Key struct {
	Topic                string   `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Action               string   `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
	LastId               string   `protobuf:"bytes,3,opt,name=lastId,proto3" json:"lastId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Key) Reset()         { *m = Key{} }
func (m *Key) String() string { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()    {}
func (*Key) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a7d11584ae62cc, []int{4}
}

func (m *Key) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Key.Unmarshal(m, b)
}
func (m *Key) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Key.Marshal(b, m, deterministic)
}
func (m *Key) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Key.Merge(m, src)
}
func (m *Key) XXX_Size() int {
	return xxx_messageInfo_Key.Size(m)
}
func (m *Key) XXX_DiscardUnknown() {
	xxx_messageInfo_Key.DiscardUnknown(m)
}

var xxx_messageInfo_Key proto.InternalMessageInfo

func (m *Key) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Key) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *Key) GetLastId() string {
	if m != nil {
		return m.LastId
	}
	return ""
}

func init() {
	proto.RegisterType((*Event)(nil), "eventstore.Event")
	proto.RegisterMapType((map[string]string)(nil), "eventstore.Event.MetadataEntry")
	proto.RegisterType((*Notification)(nil), "eventstore.Notification")
	proto.RegisterType((*DeliveryStatus)(nil), "eventstore.DeliveryStatus")
	proto.RegisterType((*SubscribeRequest)(nil), "eventstore.SubscribeRequest")
	proto.RegisterType((*Key)(nil), "eventstore.Key")
}

func init() { proto.RegisterFile("event-service.proto", fileDescriptor_03a7d11584ae62cc) }

var fileDescriptor_03a7d11584ae62cc = []byte{
	// 429 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xc1, 0x6b, 0xd4, 0x40,
	0x14, 0xc6, 0x49, 0xe2, 0x6e, 0xbb, 0xcf, 0x6e, 0xad, 0xd3, 0x52, 0x86, 0xa5, 0x60, 0xc9, 0xa9,
	0x17, 0x43, 0x89, 0x08, 0xa5, 0x05, 0x3d, 0xe8, 0x1e, 0xc2, 0x62, 0x95, 0xf4, 0xe0, 0xc5, 0xcb,
	0x24, 0x79, 0xea, 0x60, 0xcc, 0xc4, 0x99, 0x97, 0x40, 0xfe, 0x17, 0xff, 0x31, 0xff, 0x1b, 0xc9,
	0x24, 0xd9, 0xcd, 0x5a, 0x2c, 0xdd, 0x5b, 0xbe, 0x8f, 0x37, 0xdf, 0xfc, 0xe6, 0x9b, 0x09, 0x1c,
	0x63, 0x8d, 0x05, 0xbd, 0x34, 0xa8, 0x6b, 0x99, 0x62, 0x50, 0x6a, 0x45, 0x8a, 0x81, 0x35, 0x0d,
	0x29, 0x8d, 0xfe, 0x1f, 0x07, 0x26, 0xcb, 0x56, 0xb2, 0x13, 0x98, 0x90, 0x2a, 0x65, 0xca, 0x9d,
	0x73, 0xe7, 0x62, 0x16, 0x77, 0x82, 0x9d, 0xc2, 0x54, 0xa4, 0x24, 0x55, 0xc1, 0x5d, 0x6b, 0xf7,
	0x8a, 0xdd, 0xc0, 0xfe, 0x4f, 0x24, 0x91, 0x09, 0x12, 0xdc, 0x3b, 0xf7, 0x2e, 0x9e, 0x86, 0x2f,
	0x82, 0x4d, 0x6c, 0x60, 0x23, 0x83, 0x0f, 0xfd, 0xc4, 0xb2, 0x20, 0xdd, 0xc4, 0xeb, 0x05, 0x8c,
	0xc3, 0x5e, 0x29, 0x9a, 0x5c, 0x89, 0x8c, 0x3f, 0xb1, 0xa9, 0x83, 0x64, 0x87, 0xe0, 0xca, 0x8c,
	0x4f, 0xac, 0xe9, 0xca, 0x6c, 0x71, 0x03, 0xf3, 0xad, 0x10, 0x76, 0x04, 0xde, 0x0f, 0x6c, 0x7a,
	0xc6, 0xf6, 0xb3, 0xe5, 0xae, 0x45, 0x5e, 0x61, 0x0f, 0xd8, 0x89, 0x6b, 0xf7, 0xca, 0xf1, 0x7f,
	0x3b, 0x70, 0x70, 0xab, 0x48, 0x7e, 0x95, 0xa9, 0xb0, 0xd0, 0xbb, 0x1d, 0xf1, 0x14, 0xa6, 0x24,
	0xf4, 0x37, 0x24, 0xee, 0x75, 0x7e, 0xa7, 0x1e, 0x4f, 0xcf, 0xce, 0x60, 0xd6, 0x37, 0x1f, 0x65,
	0x7c, 0x6a, 0xed, 0x8d, 0xe1, 0x5f, 0xc3, 0xe1, 0x7b, 0xcc, 0x65, 0x8d, 0xba, 0xb9, 0x23, 0x41,
	0x95, 0x69, 0x93, 0x4d, 0x95, 0xa6, 0x68, 0x8c, 0x25, 0xdc, 0x8f, 0x07, 0xd9, 0x27, 0xbb, 0x43,
	0xb2, 0x1f, 0xc1, 0xd1, 0x5d, 0x95, 0x98, 0x54, 0xcb, 0x04, 0x63, 0xfc, 0x55, 0xa1, 0x21, 0xf6,
	0x1a, 0xe6, 0xa6, 0xf3, 0xca, 0x96, 0xbf, 0xcd, 0x68, 0xef, 0xe5, 0xd9, 0xf8, 0x5e, 0x56, 0xd8,
	0xc4, 0xdb, 0x53, 0xfe, 0x0a, 0xbc, 0x55, 0x57, 0xe3, 0x6e, 0xdd, 0xe4, 0xc2, 0x50, 0x94, 0x0d,
	0xdd, 0x74, 0x2a, 0x8c, 0x60, 0x6e, 0xaf, 0xfe, 0x63, 0x89, 0x5a, 0x90, 0xd2, 0xec, 0x0a, 0xf6,
	0x3e, 0x55, 0x49, 0x2e, 0xcd, 0x77, 0xf6, 0xfc, 0xde, 0x03, 0x59, 0x2c, 0xc6, 0xd6, 0x76, 0x19,
	0xe1, 0x2d, 0x1c, 0xd8, 0xa1, 0x77, 0x58, 0x90, 0x16, 0x39, 0x7b, 0x03, 0xb3, 0xf5, 0x91, 0xd9,
	0xd9, 0x78, 0xe1, 0xbf, 0x4d, 0x2c, 0xee, 0xef, 0x74, 0xe9, 0x84, 0x9f, 0xe1, 0x64, 0xfc, 0x18,
	0xd6, 0x84, 0x6f, 0x37, 0x84, 0x7c, 0xbc, 0x6e, 0x3c, 0xfc, 0x20, 0xe8, 0x17, 0x38, 0x1e, 0xcf,
	0x0e, 0xbc, 0xcb, 0xc7, 0xf3, 0xfe, 0x77, 0xdf, 0x4b, 0x27, 0x99, 0xda, 0x7f, 0xf6, 0xd5, 0xdf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0xaf, 0x19, 0xbb, 0xca, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// EventOperatorClient is the client API for EventOperator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventOperatorClient interface {
	Publish(ctx context.Context, in *Event, opts ...grpc.CallOption) (*DeliveryStatus, error)
}

type eventOperatorClient struct {
	cc grpc.ClientConnInterface
}

func NewEventOperatorClient(cc grpc.ClientConnInterface) EventOperatorClient {
	return &eventOperatorClient{cc}
}

func (c *eventOperatorClient) Publish(ctx context.Context, in *Event, opts ...grpc.CallOption) (*DeliveryStatus, error) {
	out := new(DeliveryStatus)
	err := c.cc.Invoke(ctx, "/eventstore.EventOperator/Publish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventOperatorServer is the server API for EventOperator service.
type EventOperatorServer interface {
	Publish(context.Context, *Event) (*DeliveryStatus, error)
}

// UnimplementedEventOperatorServer can be embedded to have forward compatible implementations.
type UnimplementedEventOperatorServer struct {
}

func (*UnimplementedEventOperatorServer) Publish(ctx context.Context, req *Event) (*DeliveryStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Publish not implemented")
}

func RegisterEventOperatorServer(s *grpc.Server, srv EventOperatorServer) {
	s.RegisterService(&_EventOperator_serviceDesc, srv)
}

func _EventOperator_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventOperatorServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eventstore.EventOperator/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventOperatorServer).Publish(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

var _EventOperator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "eventstore.EventOperator",
	HandlerType: (*EventOperatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Publish",
			Handler:    _EventOperator_Publish_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "event-service.proto",
}

// EventCentralClient is the client API for EventCentral service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventCentralClient interface {
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (EventCentral_SubscribeClient, error)
}

type eventCentralClient struct {
	cc grpc.ClientConnInterface
}

func NewEventCentralClient(cc grpc.ClientConnInterface) EventCentralClient {
	return &eventCentralClient{cc}
}

func (c *eventCentralClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (EventCentral_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventCentral_serviceDesc.Streams[0], "/eventstore.EventCentral/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventCentralSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventCentral_SubscribeClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type eventCentralSubscribeClient struct {
	grpc.ClientStream
}

func (x *eventCentralSubscribeClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EventCentralServer is the server API for EventCentral service.
type EventCentralServer interface {
	Subscribe(*SubscribeRequest, EventCentral_SubscribeServer) error
}

// UnimplementedEventCentralServer can be embedded to have forward compatible implementations.
type UnimplementedEventCentralServer struct {
}

func (*UnimplementedEventCentralServer) Subscribe(req *SubscribeRequest, srv EventCentral_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}

func RegisterEventCentralServer(s *grpc.Server, srv EventCentralServer) {
	s.RegisterService(&_EventCentral_serviceDesc, srv)
}

func _EventCentral_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventCentralServer).Subscribe(m, &eventCentralSubscribeServer{stream})
}

type EventCentral_SubscribeServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type eventCentralSubscribeServer struct {
	grpc.ServerStream
}

func (x *eventCentralSubscribeServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

var _EventCentral_serviceDesc = grpc.ServiceDesc{
	ServiceName: "eventstore.EventCentral",
	HandlerType: (*EventCentralServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _EventCentral_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "event-service.proto",
}

// NotificationOperatorClient is the client API for NotificationOperator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NotificationOperatorClient interface {
	Publish(ctx context.Context, in *Notification, opts ...grpc.CallOption) (*DeliveryStatus, error)
}

type notificationOperatorClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationOperatorClient(cc grpc.ClientConnInterface) NotificationOperatorClient {
	return &notificationOperatorClient{cc}
}

func (c *notificationOperatorClient) Publish(ctx context.Context, in *Notification, opts ...grpc.CallOption) (*DeliveryStatus, error) {
	out := new(DeliveryStatus)
	err := c.cc.Invoke(ctx, "/eventstore.NotificationOperator/Publish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationOperatorServer is the server API for NotificationOperator service.
type NotificationOperatorServer interface {
	Publish(context.Context, *Notification) (*DeliveryStatus, error)
}

// UnimplementedNotificationOperatorServer can be embedded to have forward compatible implementations.
type UnimplementedNotificationOperatorServer struct {
}

func (*UnimplementedNotificationOperatorServer) Publish(ctx context.Context, req *Notification) (*DeliveryStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Publish not implemented")
}

func RegisterNotificationOperatorServer(s *grpc.Server, srv NotificationOperatorServer) {
	s.RegisterService(&_NotificationOperator_serviceDesc, srv)
}

func _NotificationOperator_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Notification)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationOperatorServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eventstore.NotificationOperator/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationOperatorServer).Publish(ctx, req.(*Notification))
	}
	return interceptor(ctx, in, info, handler)
}

var _NotificationOperator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "eventstore.NotificationOperator",
	HandlerType: (*NotificationOperatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Publish",
			Handler:    _NotificationOperator_Publish_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "event-service.proto",
}

// NotificationCentralClient is the client API for NotificationCentral service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NotificationCentralClient interface {
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (NotificationCentral_SubscribeClient, error)
}

type notificationCentralClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationCentralClient(cc grpc.ClientConnInterface) NotificationCentralClient {
	return &notificationCentralClient{cc}
}

func (c *notificationCentralClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (NotificationCentral_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NotificationCentral_serviceDesc.Streams[0], "/eventstore.NotificationCentral/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &notificationCentralSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NotificationCentral_SubscribeClient interface {
	Recv() (*Notification, error)
	grpc.ClientStream
}

type notificationCentralSubscribeClient struct {
	grpc.ClientStream
}

func (x *notificationCentralSubscribeClient) Recv() (*Notification, error) {
	m := new(Notification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NotificationCentralServer is the server API for NotificationCentral service.
type NotificationCentralServer interface {
	Subscribe(*SubscribeRequest, NotificationCentral_SubscribeServer) error
}

// UnimplementedNotificationCentralServer can be embedded to have forward compatible implementations.
type UnimplementedNotificationCentralServer struct {
}

func (*UnimplementedNotificationCentralServer) Subscribe(req *SubscribeRequest, srv NotificationCentral_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}

func RegisterNotificationCentralServer(s *grpc.Server, srv NotificationCentralServer) {
	s.RegisterService(&_NotificationCentral_serviceDesc, srv)
}

func _NotificationCentral_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NotificationCentralServer).Subscribe(m, &notificationCentralSubscribeServer{stream})
}

type NotificationCentral_SubscribeServer interface {
	Send(*Notification) error
	grpc.ServerStream
}

type notificationCentralSubscribeServer struct {
	grpc.ServerStream
}

func (x *notificationCentralSubscribeServer) Send(m *Notification) error {
	return x.ServerStream.SendMsg(m)
}

var _NotificationCentral_serviceDesc = grpc.ServiceDesc{
	ServiceName: "eventstore.NotificationCentral",
	HandlerType: (*NotificationCentralServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _NotificationCentral_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "event-service.proto",
}
